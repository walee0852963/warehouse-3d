{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/waleed/Desktop/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"children\", \"compute\", \"width\", \"height\", \"samples\", \"renderPriority\", \"eventPriority\", \"frames\", \"stencilBuffer\", \"depthBuffer\", \"generateMipmaps\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nimport { useFBO } from './Fbo.js';\nconst RenderTexture = /* @__PURE__ */React.forwardRef((_ref, forwardRef) => {\n  let {\n      children,\n      compute,\n      width,\n      height,\n      samples = 8,\n      renderPriority = 0,\n      eventPriority = 0,\n      frames = Infinity,\n      stencilBuffer = false,\n      depthBuffer = true,\n      generateMipmaps = false\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const {\n    size,\n    viewport\n  } = useThree();\n  const fbo = useFBO((width || size.width) * viewport.dpr, (height || size.height) * viewport.dpr, {\n    samples,\n    stencilBuffer,\n    depthBuffer,\n    generateMipmaps\n  });\n  const [vScene] = React.useState(() => new THREE.Scene());\n  const uvCompute = React.useCallback((event, state, previous) => {\n    var _fbo$texture, _previous$previousRoo;\n    // Since this is only a texture it does not have an easy way to obtain the parent, which we\n    // need to transform event coordinates to local coordinates. We use r3f internals to find the\n    // next Object3D.\n    let parent = (_fbo$texture = fbo.texture) == null || (_fbo$texture = _fbo$texture.__r3f.parent) == null ? void 0 : _fbo$texture.object;\n    while (parent && !(parent instanceof THREE.Object3D)) {\n      var _parent$__r3f$parent;\n      parent = (_parent$__r3f$parent = parent.__r3f.parent) == null ? void 0 : _parent$__r3f$parent.object;\n    }\n    if (!parent) return false;\n    // First we call the previous state-onion-layers compute, this is what makes it possible to nest portals\n    if (!previous.raycaster.camera) previous.events.compute(event, previous, (_previous$previousRoo = previous.previousRoot) == null ? void 0 : _previous$previousRoo.getState());\n    // We run a quick check against the parent, if it isn't hit there's no need to raycast at all\n    const [intersection] = previous.raycaster.intersectObject(parent);\n    if (!intersection) return false;\n    // We take that hits uv coords, set up this layers raycaster, et voilà, we have raycasting on arbitrary surfaces\n    const uv = intersection.uv;\n    if (!uv) return false;\n    state.raycaster.setFromCamera(state.pointer.set(uv.x * 2 - 1, uv.y * 2 - 1), state.camera);\n  }, []);\n  React.useImperativeHandle(forwardRef, () => fbo.texture, [fbo]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal(/*#__PURE__*/React.createElement(Container, {\n    renderPriority: renderPriority,\n    frames: frames,\n    fbo: fbo\n  }, children, /*#__PURE__*/React.createElement(\"group\", {\n    onPointerOver: () => null\n  })), vScene, {\n    events: {\n      compute: compute || uvCompute,\n      priority: eventPriority\n    }\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: fbo.texture\n  }, props)));\n});\n\n// The container component has to be separate, it can not be inlined because \"useFrame(state\" when run inside createPortal will return\n// the portals own state which includes user-land overrides (custom cameras etc), but if it is executed in <RenderTexture>'s render function\n// it would return the default state.\nfunction Container(_ref2) {\n  let {\n    frames,\n    renderPriority,\n    children,\n    fbo\n  } = _ref2;\n  let count = 0;\n  let oldAutoClear;\n  let oldXrEnabled;\n  let oldRenderTarget;\n  let oldIsPresenting;\n  useFrame(state => {\n    if (frames === Infinity || count < frames) {\n      oldAutoClear = state.gl.autoClear;\n      oldXrEnabled = state.gl.xr.enabled;\n      oldRenderTarget = state.gl.getRenderTarget();\n      oldIsPresenting = state.gl.xr.isPresenting;\n      state.gl.autoClear = true;\n      state.gl.xr.enabled = false;\n      state.gl.xr.isPresenting = false;\n      state.gl.setRenderTarget(fbo);\n      state.gl.render(state.scene, state.camera);\n      state.gl.setRenderTarget(oldRenderTarget);\n      state.gl.autoClear = oldAutoClear;\n      state.gl.xr.enabled = oldXrEnabled;\n      state.gl.xr.isPresenting = oldIsPresenting;\n      count++;\n    }\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\nexport { RenderTexture };","map":{"version":3,"names":["_extends","THREE","React","useThree","createPortal","useFrame","useFBO","RenderTexture","forwardRef","_ref","children","compute","width","height","samples","renderPriority","eventPriority","frames","Infinity","stencilBuffer","depthBuffer","generateMipmaps","props","_objectWithoutProperties","_excluded","size","viewport","fbo","dpr","vScene","useState","Scene","uvCompute","useCallback","event","state","previous","_fbo$texture","_previous$previousRoo","parent","texture","__r3f","object","Object3D","_parent$__r3f$parent","raycaster","camera","events","previousRoot","getState","intersection","intersectObject","uv","setFromCamera","pointer","set","x","y","useImperativeHandle","createElement","Fragment","Container","onPointerOver","priority","_ref2","count","oldAutoClear","oldXrEnabled","oldRenderTarget","oldIsPresenting","gl","autoClear","xr","enabled","getRenderTarget","isPresenting","setRenderTarget","render","scene"],"sources":["C:/Users/waleed/Desktop/node_modules/@react-three/drei/core/RenderTexture.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nimport { useFBO } from './Fbo.js';\n\nconst RenderTexture = /* @__PURE__ */React.forwardRef(({\n  children,\n  compute,\n  width,\n  height,\n  samples = 8,\n  renderPriority = 0,\n  eventPriority = 0,\n  frames = Infinity,\n  stencilBuffer = false,\n  depthBuffer = true,\n  generateMipmaps = false,\n  ...props\n}, forwardRef) => {\n  const {\n    size,\n    viewport\n  } = useThree();\n  const fbo = useFBO((width || size.width) * viewport.dpr, (height || size.height) * viewport.dpr, {\n    samples,\n    stencilBuffer,\n    depthBuffer,\n    generateMipmaps\n  });\n  const [vScene] = React.useState(() => new THREE.Scene());\n  const uvCompute = React.useCallback((event, state, previous) => {\n    var _fbo$texture, _previous$previousRoo;\n    // Since this is only a texture it does not have an easy way to obtain the parent, which we\n    // need to transform event coordinates to local coordinates. We use r3f internals to find the\n    // next Object3D.\n    let parent = (_fbo$texture = fbo.texture) == null || (_fbo$texture = _fbo$texture.__r3f.parent) == null ? void 0 : _fbo$texture.object;\n    while (parent && !(parent instanceof THREE.Object3D)) {\n      var _parent$__r3f$parent;\n      parent = (_parent$__r3f$parent = parent.__r3f.parent) == null ? void 0 : _parent$__r3f$parent.object;\n    }\n    if (!parent) return false;\n    // First we call the previous state-onion-layers compute, this is what makes it possible to nest portals\n    if (!previous.raycaster.camera) previous.events.compute(event, previous, (_previous$previousRoo = previous.previousRoot) == null ? void 0 : _previous$previousRoo.getState());\n    // We run a quick check against the parent, if it isn't hit there's no need to raycast at all\n    const [intersection] = previous.raycaster.intersectObject(parent);\n    if (!intersection) return false;\n    // We take that hits uv coords, set up this layers raycaster, et voilà, we have raycasting on arbitrary surfaces\n    const uv = intersection.uv;\n    if (!uv) return false;\n    state.raycaster.setFromCamera(state.pointer.set(uv.x * 2 - 1, uv.y * 2 - 1), state.camera);\n  }, []);\n  React.useImperativeHandle(forwardRef, () => fbo.texture, [fbo]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal(/*#__PURE__*/React.createElement(Container, {\n    renderPriority: renderPriority,\n    frames: frames,\n    fbo: fbo\n  }, children, /*#__PURE__*/React.createElement(\"group\", {\n    onPointerOver: () => null\n  })), vScene, {\n    events: {\n      compute: compute || uvCompute,\n      priority: eventPriority\n    }\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: fbo.texture\n  }, props)));\n});\n\n// The container component has to be separate, it can not be inlined because \"useFrame(state\" when run inside createPortal will return\n// the portals own state which includes user-land overrides (custom cameras etc), but if it is executed in <RenderTexture>'s render function\n// it would return the default state.\nfunction Container({\n  frames,\n  renderPriority,\n  children,\n  fbo\n}) {\n  let count = 0;\n  let oldAutoClear;\n  let oldXrEnabled;\n  let oldRenderTarget;\n  let oldIsPresenting;\n  useFrame(state => {\n    if (frames === Infinity || count < frames) {\n      oldAutoClear = state.gl.autoClear;\n      oldXrEnabled = state.gl.xr.enabled;\n      oldRenderTarget = state.gl.getRenderTarget();\n      oldIsPresenting = state.gl.xr.isPresenting;\n      state.gl.autoClear = true;\n      state.gl.xr.enabled = false;\n      state.gl.xr.isPresenting = false;\n      state.gl.setRenderTarget(fbo);\n      state.gl.render(state.scene, state.camera);\n      state.gl.setRenderTarget(oldRenderTarget);\n      state.gl.autoClear = oldAutoClear;\n      state.gl.xr.enabled = oldXrEnabled;\n      state.gl.xr.isPresenting = oldIsPresenting;\n      count++;\n    }\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\n\nexport { RenderTexture };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}