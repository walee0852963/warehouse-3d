{"ast":null,"code":"import _objectSpread from \"C:/Users/waleed/Desktop/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/waleed/Desktop/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"scale\", \"frames\", \"opacity\", \"width\", \"height\", \"blur\", \"near\", \"far\", \"resolution\", \"smooth\", \"color\", \"depthWrite\", \"renderOrder\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { HorizontalBlurShader, VerticalBlurShader } from 'three-stdlib';\nconst ContactShadows = /* @__PURE__ */React.forwardRef((_ref, fref) => {\n  let {\n      scale = 10,\n      frames = Infinity,\n      opacity = 1,\n      width = 1,\n      height = 1,\n      blur = 1,\n      near = 0,\n      far = 10,\n      resolution = 512,\n      smooth = true,\n      color = '#000000',\n      depthWrite = false,\n      renderOrder\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const ref = React.useRef(null);\n  const scene = useThree(state => state.scene);\n  const gl = useThree(state => state.gl);\n  const shadowCamera = React.useRef(null);\n  width = width * (Array.isArray(scale) ? scale[0] : scale || 1);\n  height = height * (Array.isArray(scale) ? scale[1] : scale || 1);\n  const [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = React.useMemo(() => {\n    const renderTarget = new THREE.WebGLRenderTarget(resolution, resolution);\n    const renderTargetBlur = new THREE.WebGLRenderTarget(resolution, resolution);\n    renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;\n    const planeGeometry = new THREE.PlaneGeometry(width, height).rotateX(Math.PI / 2);\n    const blurPlane = new THREE.Mesh(planeGeometry);\n    const depthMaterial = new THREE.MeshDepthMaterial();\n    depthMaterial.depthTest = depthMaterial.depthWrite = false;\n    depthMaterial.onBeforeCompile = shader => {\n      shader.uniforms = _objectSpread(_objectSpread({}, shader.uniforms), {}, {\n        ucolor: {\n          value: new THREE.Color(color)\n        }\n      });\n      shader.fragmentShader = shader.fragmentShader.replace(\"void main() {\", //\n      \"uniform vec3 ucolor;\\n           void main() {\\n          \");\n      shader.fragmentShader = shader.fragmentShader.replace('vec4( vec3( 1.0 - fragCoordZ ), opacity );',\n      // Colorize the shadow, multiply by the falloff so that the center can remain darker\n      'vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );');\n    };\n    const horizontalBlurMaterial = new THREE.ShaderMaterial(HorizontalBlurShader);\n    const verticalBlurMaterial = new THREE.ShaderMaterial(VerticalBlurShader);\n    verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;\n    return [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur];\n  }, [resolution, width, height, scale, color]);\n  const blurShadows = blur => {\n    blurPlane.visible = true;\n    blurPlane.material = horizontalBlurMaterial;\n    horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;\n    horizontalBlurMaterial.uniforms.h.value = blur * 1 / 256;\n    gl.setRenderTarget(renderTargetBlur);\n    gl.render(blurPlane, shadowCamera.current);\n    blurPlane.material = verticalBlurMaterial;\n    verticalBlurMaterial.uniforms.tDiffuse.value = renderTargetBlur.texture;\n    verticalBlurMaterial.uniforms.v.value = blur * 1 / 256;\n    gl.setRenderTarget(renderTarget);\n    gl.render(blurPlane, shadowCamera.current);\n    blurPlane.visible = false;\n  };\n  let count = 0;\n  let initialBackground;\n  let initialOverrideMaterial;\n  useFrame(() => {\n    if (shadowCamera.current && (frames === Infinity || count < frames)) {\n      count++;\n      initialBackground = scene.background;\n      initialOverrideMaterial = scene.overrideMaterial;\n      ref.current.visible = false;\n      scene.background = null;\n      scene.overrideMaterial = depthMaterial;\n      gl.setRenderTarget(renderTarget);\n      gl.render(scene, shadowCamera.current);\n      blurShadows(blur);\n      if (smooth) blurShadows(blur * 0.4);\n      gl.setRenderTarget(null);\n      ref.current.visible = true;\n      scene.overrideMaterial = initialOverrideMaterial;\n      scene.background = initialBackground;\n    }\n  });\n  React.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    \"rotation-x\": Math.PI / 2\n  }, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"mesh\", {\n    renderOrder: renderOrder,\n    geometry: planeGeometry,\n    scale: [1, -1, 1],\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    transparent: true,\n    map: renderTarget.texture,\n    opacity: opacity,\n    depthWrite: depthWrite\n  })), /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: shadowCamera,\n    args: [-width / 2, width / 2, height / 2, -height / 2, near, far]\n  }));\n});\nexport { ContactShadows };","map":{"version":3,"names":["_extends","React","THREE","useThree","useFrame","HorizontalBlurShader","VerticalBlurShader","ContactShadows","forwardRef","_ref","fref","scale","frames","Infinity","opacity","width","height","blur","near","far","resolution","smooth","color","depthWrite","renderOrder","props","_objectWithoutProperties","_excluded","ref","useRef","scene","state","gl","shadowCamera","Array","isArray","renderTarget","planeGeometry","depthMaterial","blurPlane","horizontalBlurMaterial","verticalBlurMaterial","renderTargetBlur","useMemo","WebGLRenderTarget","texture","generateMipmaps","PlaneGeometry","rotateX","Math","PI","Mesh","MeshDepthMaterial","depthTest","onBeforeCompile","shader","uniforms","_objectSpread","ucolor","value","Color","fragmentShader","replace","ShaderMaterial","blurShadows","visible","material","tDiffuse","h","setRenderTarget","render","current","v","count","initialBackground","initialOverrideMaterial","background","overrideMaterial","useImperativeHandle","createElement","geometry","rotation","transparent","map","args"],"sources":["C:/Users/waleed/Desktop/node_modules/@react-three/drei/core/ContactShadows.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { HorizontalBlurShader, VerticalBlurShader } from 'three-stdlib';\n\nconst ContactShadows = /* @__PURE__ */React.forwardRef(({\n  scale = 10,\n  frames = Infinity,\n  opacity = 1,\n  width = 1,\n  height = 1,\n  blur = 1,\n  near = 0,\n  far = 10,\n  resolution = 512,\n  smooth = true,\n  color = '#000000',\n  depthWrite = false,\n  renderOrder,\n  ...props\n}, fref) => {\n  const ref = React.useRef(null);\n  const scene = useThree(state => state.scene);\n  const gl = useThree(state => state.gl);\n  const shadowCamera = React.useRef(null);\n  width = width * (Array.isArray(scale) ? scale[0] : scale || 1);\n  height = height * (Array.isArray(scale) ? scale[1] : scale || 1);\n  const [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = React.useMemo(() => {\n    const renderTarget = new THREE.WebGLRenderTarget(resolution, resolution);\n    const renderTargetBlur = new THREE.WebGLRenderTarget(resolution, resolution);\n    renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;\n    const planeGeometry = new THREE.PlaneGeometry(width, height).rotateX(Math.PI / 2);\n    const blurPlane = new THREE.Mesh(planeGeometry);\n    const depthMaterial = new THREE.MeshDepthMaterial();\n    depthMaterial.depthTest = depthMaterial.depthWrite = false;\n    depthMaterial.onBeforeCompile = shader => {\n      shader.uniforms = {\n        ...shader.uniforms,\n        ucolor: {\n          value: new THREE.Color(color)\n        }\n      };\n      shader.fragmentShader = shader.fragmentShader.replace(`void main() {`,\n      //\n      `uniform vec3 ucolor;\n           void main() {\n          `);\n      shader.fragmentShader = shader.fragmentShader.replace('vec4( vec3( 1.0 - fragCoordZ ), opacity );',\n      // Colorize the shadow, multiply by the falloff so that the center can remain darker\n      'vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );');\n    };\n    const horizontalBlurMaterial = new THREE.ShaderMaterial(HorizontalBlurShader);\n    const verticalBlurMaterial = new THREE.ShaderMaterial(VerticalBlurShader);\n    verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;\n    return [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur];\n  }, [resolution, width, height, scale, color]);\n  const blurShadows = blur => {\n    blurPlane.visible = true;\n    blurPlane.material = horizontalBlurMaterial;\n    horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;\n    horizontalBlurMaterial.uniforms.h.value = blur * 1 / 256;\n    gl.setRenderTarget(renderTargetBlur);\n    gl.render(blurPlane, shadowCamera.current);\n    blurPlane.material = verticalBlurMaterial;\n    verticalBlurMaterial.uniforms.tDiffuse.value = renderTargetBlur.texture;\n    verticalBlurMaterial.uniforms.v.value = blur * 1 / 256;\n    gl.setRenderTarget(renderTarget);\n    gl.render(blurPlane, shadowCamera.current);\n    blurPlane.visible = false;\n  };\n  let count = 0;\n  let initialBackground;\n  let initialOverrideMaterial;\n  useFrame(() => {\n    if (shadowCamera.current && (frames === Infinity || count < frames)) {\n      count++;\n      initialBackground = scene.background;\n      initialOverrideMaterial = scene.overrideMaterial;\n      ref.current.visible = false;\n      scene.background = null;\n      scene.overrideMaterial = depthMaterial;\n      gl.setRenderTarget(renderTarget);\n      gl.render(scene, shadowCamera.current);\n      blurShadows(blur);\n      if (smooth) blurShadows(blur * 0.4);\n      gl.setRenderTarget(null);\n      ref.current.visible = true;\n      scene.overrideMaterial = initialOverrideMaterial;\n      scene.background = initialBackground;\n    }\n  });\n  React.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    \"rotation-x\": Math.PI / 2\n  }, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"mesh\", {\n    renderOrder: renderOrder,\n    geometry: planeGeometry,\n    scale: [1, -1, 1],\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    transparent: true,\n    map: renderTarget.texture,\n    opacity: opacity,\n    depthWrite: depthWrite\n  })), /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: shadowCamera,\n    args: [-width / 2, width / 2, height / 2, -height / 2, near, far]\n  }));\n});\n\nexport { ContactShadows };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}