{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/waleed/Desktop/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"renderPriority\", \"zoom\", \"segments\", \"children\", \"resolution\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { RenderCubeTexture } from './RenderCubeTexture.js';\nfunction Fisheye(_ref) {\n  let {\n      renderPriority = 1,\n      zoom = 0,\n      segments = 64,\n      children,\n      resolution = 896\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const sphere = React.useRef(null);\n  const cubeApi = React.useRef(null);\n\n  // This isn't more than a simple sphere and a fixed orthographc camera\n  // pointing at it. A virtual scene is portalled into the environment map\n  // of its material. The cube-camera filming that scene is being synced to\n  // the portals default camera with the <UpdateCubeCamera> component.\n\n  const {\n    width,\n    height\n  } = useThree(state => state.size);\n  const [orthoC] = React.useState(() => new THREE.OrthographicCamera());\n  React.useLayoutEffect(() => {\n    orthoC.position.set(0, 0, 100);\n    orthoC.zoom = 100;\n    orthoC.left = width / -2;\n    orthoC.right = width / 2;\n    orthoC.top = height / 2;\n    orthoC.bottom = height / -2;\n    orthoC.updateProjectionMatrix();\n  }, [width, height]);\n  const radius = Math.sqrt(width * width + height * height) / 100 * (0.5 + zoom / 2);\n  const normal = new THREE.Vector3();\n  const sph = new THREE.Sphere(new THREE.Vector3(), radius);\n  const normalMatrix = new THREE.Matrix3();\n  const compute = React.useCallback((event, state, prev) => {\n    // Raycast from the render camera to the sphere and get the surface normal\n    // of the point hit in world space of the sphere scene\n    // We have to set the raycaster using the orthocam and pointer\n    // to perform sphere interscetions.\n    state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n    state.raycaster.setFromCamera(state.pointer, orthoC);\n    if (!state.raycaster.ray.intersectSphere(sph, normal)) return;else normal.normalize();\n    // Get the matrix for transforming normals into world space\n    normalMatrix.getNormalMatrix(cubeApi.current.camera.matrixWorld);\n    // Get the ray\n    cubeApi.current.camera.getWorldPosition(state.raycaster.ray.origin);\n    state.raycaster.ray.direction.set(0, 0, 1).reflect(normal);\n    state.raycaster.ray.direction.x *= -1; // flip across X to accommodate the \"flip\" of the env map\n    state.raycaster.ray.direction.applyNormalMatrix(normalMatrix).multiplyScalar(-1);\n    return undefined;\n  }, []);\n  useFrame(state => {\n    // Take over rendering\n    if (renderPriority) state.gl.render(sphere.current, orthoC);\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: sphere\n  }, props, {\n    scale: radius\n  }), /*#__PURE__*/React.createElement(\"sphereGeometry\", {\n    args: [1, segments, segments]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", null, /*#__PURE__*/React.createElement(RenderCubeTexture, {\n    compute: compute,\n    attach: \"envMap\",\n    flip: true,\n    resolution: resolution,\n    ref: cubeApi\n  }, children, /*#__PURE__*/React.createElement(UpdateCubeCamera, {\n    api: cubeApi\n  })))));\n}\nfunction UpdateCubeCamera(_ref2) {\n  let {\n    api\n  } = _ref2;\n  const t = new THREE.Vector3();\n  const r = new THREE.Quaternion();\n  const s = new THREE.Vector3();\n  const e = new THREE.Euler(0, Math.PI, 0);\n  useFrame(state => {\n    // Read out the cameras whereabouts, state.camera is the one *within* the portal\n    state.camera.matrixWorld.decompose(t, r, s);\n    // Apply its position and rotation, flip the Y axis\n    api.current.camera.position.copy(t);\n    api.current.camera.quaternion.setFromEuler(e).premultiply(r);\n  });\n  return null;\n}\nexport { Fisheye };","map":{"version":3,"names":["_extends","THREE","React","useThree","useFrame","RenderCubeTexture","Fisheye","_ref","renderPriority","zoom","segments","children","resolution","props","_objectWithoutProperties","_excluded","sphere","useRef","cubeApi","width","height","state","size","orthoC","useState","OrthographicCamera","useLayoutEffect","position","set","left","right","top","bottom","updateProjectionMatrix","radius","Math","sqrt","normal","Vector3","sph","Sphere","normalMatrix","Matrix3","compute","useCallback","event","prev","pointer","offsetX","offsetY","raycaster","setFromCamera","ray","intersectSphere","normalize","getNormalMatrix","current","camera","matrixWorld","getWorldPosition","origin","direction","reflect","x","applyNormalMatrix","multiplyScalar","undefined","gl","render","createElement","Fragment","ref","scale","args","attach","flip","UpdateCubeCamera","api","_ref2","t","r","Quaternion","s","e","Euler","PI","decompose","copy","quaternion","setFromEuler","premultiply"],"sources":["C:/Users/waleed/Desktop/node_modules/@react-three/drei/core/Fisheye.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { RenderCubeTexture } from './RenderCubeTexture.js';\n\nfunction Fisheye({\n  renderPriority = 1,\n  zoom = 0,\n  segments = 64,\n  children,\n  resolution = 896,\n  ...props\n}) {\n  const sphere = React.useRef(null);\n  const cubeApi = React.useRef(null);\n\n  // This isn't more than a simple sphere and a fixed orthographc camera\n  // pointing at it. A virtual scene is portalled into the environment map\n  // of its material. The cube-camera filming that scene is being synced to\n  // the portals default camera with the <UpdateCubeCamera> component.\n\n  const {\n    width,\n    height\n  } = useThree(state => state.size);\n  const [orthoC] = React.useState(() => new THREE.OrthographicCamera());\n  React.useLayoutEffect(() => {\n    orthoC.position.set(0, 0, 100);\n    orthoC.zoom = 100;\n    orthoC.left = width / -2;\n    orthoC.right = width / 2;\n    orthoC.top = height / 2;\n    orthoC.bottom = height / -2;\n    orthoC.updateProjectionMatrix();\n  }, [width, height]);\n  const radius = Math.sqrt(width * width + height * height) / 100 * (0.5 + zoom / 2);\n  const normal = new THREE.Vector3();\n  const sph = new THREE.Sphere(new THREE.Vector3(), radius);\n  const normalMatrix = new THREE.Matrix3();\n  const compute = React.useCallback((event, state, prev) => {\n    // Raycast from the render camera to the sphere and get the surface normal\n    // of the point hit in world space of the sphere scene\n    // We have to set the raycaster using the orthocam and pointer\n    // to perform sphere interscetions.\n    state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n    state.raycaster.setFromCamera(state.pointer, orthoC);\n    if (!state.raycaster.ray.intersectSphere(sph, normal)) return;else normal.normalize();\n    // Get the matrix for transforming normals into world space\n    normalMatrix.getNormalMatrix(cubeApi.current.camera.matrixWorld);\n    // Get the ray\n    cubeApi.current.camera.getWorldPosition(state.raycaster.ray.origin);\n    state.raycaster.ray.direction.set(0, 0, 1).reflect(normal);\n    state.raycaster.ray.direction.x *= -1; // flip across X to accommodate the \"flip\" of the env map\n    state.raycaster.ray.direction.applyNormalMatrix(normalMatrix).multiplyScalar(-1);\n    return undefined;\n  }, []);\n  useFrame(state => {\n    // Take over rendering\n    if (renderPriority) state.gl.render(sphere.current, orthoC);\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: sphere\n  }, props, {\n    scale: radius\n  }), /*#__PURE__*/React.createElement(\"sphereGeometry\", {\n    args: [1, segments, segments]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", null, /*#__PURE__*/React.createElement(RenderCubeTexture, {\n    compute: compute,\n    attach: \"envMap\",\n    flip: true,\n    resolution: resolution,\n    ref: cubeApi\n  }, children, /*#__PURE__*/React.createElement(UpdateCubeCamera, {\n    api: cubeApi\n  })))));\n}\nfunction UpdateCubeCamera({\n  api\n}) {\n  const t = new THREE.Vector3();\n  const r = new THREE.Quaternion();\n  const s = new THREE.Vector3();\n  const e = new THREE.Euler(0, Math.PI, 0);\n  useFrame(state => {\n    // Read out the cameras whereabouts, state.camera is the one *within* the portal\n    state.camera.matrixWorld.decompose(t, r, s);\n    // Apply its position and rotation, flip the Y axis\n    api.current.camera.position.copy(t);\n    api.current.camera.quaternion.setFromEuler(e).premultiply(r);\n  });\n  return null;\n}\n\nexport { Fisheye };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}