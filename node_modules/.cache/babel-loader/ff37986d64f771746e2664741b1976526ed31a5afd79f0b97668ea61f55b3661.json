{"ast":null,"code":"import { Vector3 as Vector3$1, Quaternion as Quaternion$1, ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, Fragment } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferGeometry, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\nimport { suspend } from 'suspend-react';\nimport { mergeVertices } from 'three-stdlib';\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nnew Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = _ref2 => {\n  let {\n    x,\n    y,\n    z,\n    w\n  } = _ref2;\n  return _quaternion.set(x, y, z, w);\n};\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new Vector3$1(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new Vector3$1(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new Vector3$1(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new Quaternion$1(v[0], v[1], v[2], v[3]);\n  } else {\n    return new Quaternion$1(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n  if (Array.isArray(v)) {\n    return v;\n  }\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef(undefined);\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n  return ref.current.value;\n}\nconst useRaf = callback => {\n  const cb = useRef(callback);\n  const raf = useRef(0);\n  const lastFrame = useRef(0);\n  useEffect(() => {\n    cb.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\nconst UseFrameStepper = _ref3 => {\n  let {\n    onStep,\n    updatePriority\n  } = _ref3;\n  useFrame((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\nconst RafStepper = _ref4 => {\n  let {\n    onStep\n  } = _ref4;\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\nconst FrameStepper = _ref5 => {\n  let {\n    onStep,\n    type,\n    updatePriority\n  } = _ref5;\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\", \"softCcdPrediction\", \"ref\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice();\n\n  // Heightfield uses a vector\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  }\n\n  // Trimesh and convex scale the vertices\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  }\n\n  // Prepfill with some extra\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale);\n  // @ts-ignore\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setDensity(options.density);\n    return;\n  }\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setMass(options.mass);\n    return;\n  }\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  activeCollisionTypes: (collider, value) => {\n    collider.setActiveCollisionTypes(value);\n  },\n  contactSkin: (collider, value) => {\n    collider.setContactSkin(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n  if (state) {\n    var _state$worldParent;\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n    _matrix4.copy(state.object.matrixWorld);\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n    _matrix4.decompose(_position, _rotation, _scale);\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider,\n        // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    });\n\n    // handle mass separately, because the assignments\n    // are exclusive.\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = _ref6 => {\n  let {\n    object,\n    ignoreMeshColliders: _ignoreMeshColliders = true,\n    options\n  } = _ref6;\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n      childColliderProps.push(colliderProps);\n    }\n  };\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = function (getCollider, props, events) {\n  let activeEvents = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    const collider = getCollider();\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = function () {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const rest = _objectWithoutProperties(props, _excluded$2);\n  return rest;\n};\n\n// Utils\nconst useMutableCallback = fn => {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n};\n\n// External hooks\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\nconst useRapier = () => {\n  const rapier = useContext(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n// Internal hooks\n/**\n * @internal\n */\nconst useChildColliderProps = function (ref, options) {\n  let ignoreMeshColliders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n    mesh.geometry.dispose();\n    mesh.geometry = geometry;\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.get(instance, prop);\n    },\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.set(instance, prop, value);\n    }\n  };\n  const proxy = new Proxy({}, handler);\n  const reset = () => {\n    instance = undefined;\n  };\n  const set = newInstance => {\n    instance = newInstance;\n  };\n\n  /**\n   * Return the proxy and a reset function\n   */\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\nconst rapierContext = /*#__PURE__*/createContext(undefined);\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    contactNaturalFrequency = 30,\n    lengthUnit = 1\n  } = props;\n  const rapier = suspend(importRapier, [\"@react-thee/rapier\", importRapier]);\n  const {\n    invalidate\n  } = useThree();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  useEffect(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []);\n\n  // Update mutable props\n  useEffect(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.normalizedAllowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.normalizedPredictionDistance = predictionDistance;\n    worldProxy.lengthUnit = lengthUnit;\n    worldProxy.integrationParameters.contact_natural_frequency = contactNaturalFrequency;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, lengthUnit, contactNaturalFrequency]);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    var _collider$parent;\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldProxy;\n\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n    const timeStepVariable = timeStep === \"vary\";\n\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue);\n\n      // Trigger afterStep callbacks\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep;\n\n    // Update meshes\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n        state.isSleeping = rigidBody.isSleeping();\n      }\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      }\n\n      // New states\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n        // Apply previous tick position\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      }\n\n      // Get new position\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2);\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n\n          /* Collider events */\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      }\n\n      // Sensor Intersections\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2());\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = useMemo(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = useCallback(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\n};\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n// Need to catch the case where forwardedRef is a function... how to do that?\nconst useForwardedRef = function (forwardedRef) {\n  let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const innerRef = useRef(defaultValue);\n\n  // Update the forwarded ref when the inner ref changes\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n    return forwardedRef;\n  }\n  return innerRef;\n};\n\n/**\n * Initiate an instance and return a safe getter\n */\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = useRef(undefined);\n  const getInstance = useCallback(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n    return ref.current;\n  }, dependencyList);\n  useEffect(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n    const destroy = () => destroyFn(instance);\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type);\n\n  // Apply immutable options\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = _ref7 => {\n  let {\n    rigidBody,\n    object,\n    setMatrix,\n    getMatrix,\n    worldScale,\n    meshType: _meshType = \"mesh\"\n  } = _ref7;\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, _ref8) => {\n    let [x, y, z] = _ref8;\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, _ref9) => {\n    let [x, y, z] = _ref9;\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, _ref0) => {\n    let [x, y, z] = _ref0;\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, _ref1) => {\n    let [x, y, z] = _ref1;\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  softCcdPrediction: (rb, value) => {\n    rb.setSoftCcdPrediction(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = function (rigidBody, options, states) {\n  let updateTranslations = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (!rigidBody) {\n    return;\n  }\n  const state = states.get(rigidBody.handle);\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = function (getRigidBody, props, states) {\n  let updateTranslations = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\nconst vec3 = function () {\n  let {\n    x,\n    y,\n    z\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    x: 0,\n    y: 0,\n    z: 0\n  };\n  return new Vector3(x, y, z);\n};\n\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\nconst quat = function () {\n  let {\n    x,\n    y,\n    z,\n    w\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    x: 0,\n    y: 0,\n    z: 0,\n    w: 1\n  };\n  return new Quaternion(x, y, z, w);\n};\n\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\nconst euler = function () {\n  let {\n    x,\n    y,\n    z\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    x: 0,\n    y: 0,\n    z: 0\n  };\n  return new Euler(x, y, z);\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(props.ref);\n  const objectRef = useRef(null);\n\n  // We spread the props out here to make sure that the ref is updated when the props change.\n  const immutablePropArray = immutableColliderOptions.flatMap(key =>\n  // Array.isArray(props[key]) ? [...props[key]] : props[key]\n  Array.isArray(props[key]) ? props[key] : [props[key]]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n    if (typeof props.ref == \"function\") {\n      props.ref(collider);\n    }\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  useEffect(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n});\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\nconst _excluded$1 = [\"ref\", \"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/memo(props => {\n  const {\n      ref,\n      children,\n      type,\n      position,\n      rotation,\n      scale,\n      quaternion,\n      transformState\n    } = props,\n    objectProps = _objectWithoutProperties(props, _excluded$1);\n  const objectRef = useRef(null);\n  const rigidBodyRef = useForwardedRef(ref);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions);\n\n  // Provide a way to eagerly create rigidbody\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n    if (typeof ref === \"function\") {\n      ref(rigidBody);\n    }\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray);\n\n  // Only provide a object state after the ref has been set\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n});\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\nconst _excluded = [\"ref\"],\n  _excluded2 = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/memo(_ref => {\n  let {\n      ref\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const rigidBodiesRef = useForwardedRef(ref, []);\n  const objectRef = useRef(null);\n  const instanceWrapperRef = useRef(null);\n  const {\n      // instanced props\n      children,\n      instances,\n      colliderNodes = [],\n      // wrapper object props\n      position,\n      rotation,\n      quaternion,\n      scale\n\n      // rigid body specific props, and r3f-object props\n    } = props,\n    rigidBodyProps = _objectWithoutProperties(props, _excluded2);\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n    return undefined;\n  };\n  useEffect(() => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []);\n\n  // Update the RigidBodyStates whenever the instances change\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n    return state;\n  };\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => {\n      rigidBodiesRef.current[index] = body;\n    },\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n});\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef(undefined);\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\nconst useFixedJoint = (body1, body2, _ref10) => {\n  let [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame] = _ref10;\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useSphericalJoint = (body1, body2, _ref11) => {\n  let [body1Anchor, body2Anchor] = _ref11;\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useRevoluteJoint = (body1, body2, _ref12) => {\n  let [body1Anchor, body2Anchor, axis, limits] = _ref12;\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst usePrismaticJoint = (body1, body2, _ref13) => {\n  let [body1Anchor, body2Anchor, axis, limits] = _ref13;\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\nconst useRopeJoint = (body1, body2, _ref14) => {\n  let [body1Anchor, body2Anchor, length] = _ref14;\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\nconst useSpringJoint = (body1, body2, _ref15) => {\n  let [body1Anchor, body2Anchor, restLength, stiffness, damping] = _ref15;\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRopeJoint, useSphericalJoint, useSpringJoint, vec3 };","map":{"version":3,"names":["Vector3","Vector3$1","Quaternion","Quaternion$1","ActiveEvents","ColliderDesc","EventQueue","RigidBodyDesc","CoefficientCombineRule","Collider","RapierCollider","RigidBody","RapierRigidBody","useFrame","useThree","React","useRef","useEffect","memo","useMemo","useContext","useState","createContext","useCallback","Fragment","Euler","Object3D","Matrix4","BufferGeometry","BufferAttribute","MathUtils","DynamicDrawUsage","suspend","mergeVertices","_toPrimitive","t","r","e","Symbol","toPrimitive","i","call","TypeError","String","Number","_toPropertyKey","_defineProperty","Object","defineProperty","value","enumerable","configurable","writable","ownKeys","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","_quaternion","_vector3","_matrix4","_position","_rotation","_scale","vectorArrayToVector3","arr","x","y","z","rapierQuaternionToQuaternion","_ref2","w","set","vector3ToRapierVector","v","Array","isArray","threeVector3","quaternionToRapierQuaternion","rigidBodyTypeMap","fixed","dynamic","kinematicPosition","kinematicVelocity","rigidBodyTypeFromString","type","scaleVertices","vertices","scale","scaledVerts","from","vectorToTuple","useConst","initialValue","ref","undefined","current","useRaf","callback","cb","raf","lastFrame","loop","now","performance","delta","requestAnimationFrame","cancelAnimationFrame","UseFrameStepper","_ref3","onStep","updatePriority","_","dt","RafStepper","_ref4","FrameStepper","_ref5","createElement","FrameStepper$1","_objectWithoutPropertiesLoose","n","hasOwnProperty","indexOf","_objectWithoutProperties","propertyIsEnumerable","_excluded$2","scaleColliderArgs","shape","args","newArgs","slice","s","scaleArray","map","arg","index","createColliderFromOptions","options","world","getRigidBody","scaledArgs","desc","createCollider","immutableColliderOptions","massPropertiesConflictError","setColliderMassOptions","collider","density","mass","massProperties","Error","setDensity","setMass","setMassProperties","centerOfMass","principalAngularInertia","angularInertiaLocalFrame","mutableColliderOptions","sensor","setSensor","collisionGroups","setCollisionGroups","solverGroups","setSolverGroups","friction","setFriction","frictionCombineRule","setFrictionCombineRule","restitution","setRestitution","restitutionCombineRule","setRestitutionCombineRule","activeCollisionTypes","setActiveCollisionTypes","contactSkin","setContactSkin","quaternion","position","rotation","mutableColliderOptionKeys","setColliderOptions","states","state","get","handle","_state$worldParent","parentWorldScale","object","parent","getWorldScale","parentInvertedWorldMatrix","worldParent","matrixWorld","clone","invert","updateWorldMatrix","copy","premultiply","decompose","setTranslationWrtParent","setRotationWrtParent","setTranslation","setRotation","key","option","useUpdateColliderOptions","getCollider","props","mutablePropsAsFlatArray","flatMap","isChildOfMeshCollider","child","flag","traverseAncestors","a","userData","r3RapierType","createColliderState","rigidBodyObject","autoColliderMap","cuboid","ball","hull","trimesh","createColliderPropsFromChildren","_ref6","ignoreMeshColliders","_ignoreMeshColliders","childColliderProps","invertedParentMatrixWorld","colliderFromChild","worldScale","colliders","rotationEuler","setFromQuaternion","geometry","offset","getColliderArgsFromGeometry","colliderProps","cleanRigidBodyPropsForCollider","includeInvisible","traverse","traverseVisible","computeBoundingBox","boundingBox","size","getSize","getCenter","computeBoundingSphere","boundingSphere","radius","center","_clonedGeometry$index","clonedGeometry","attributes","array","g","getActiveCollisionEventsFromProps","collision","onCollisionEnter","onCollisionExit","onIntersectionEnter","onIntersectionExit","contactForce","onContactForce","useColliderEvents","events","activeEvents","collisionEventsActive","contactForceEventsActive","hasCollisionEvent","hasContactForceEvent","setActiveEvents","COLLISION_EVENTS","CONTACT_FORCE_EVENTS","delete","rest","useMutableCallback","fn","useRapier","rapier","rapierContext","useBeforePhysicsStep","beforeStepCallbacks","add","useAfterPhysicsStep","afterStepCallbacks","useChildColliderProps","setColliderProps","Debug","mesh","buffers","debugRender","setAttribute","colors","dispose","frustumCulled","color","vertexColors","createSingletonProxy","createInstance","instance","handler","target","prop","Reflect","proxy","Proxy","reset","newInstance","getCollisionPayloadFromSource","other","_target$collider$stat","_target$rigidBody$sta","_other$collider$state","_other$rigidBody$stat","_other$collider$state2","_other$rigidBody$stat2","rigidBody","colliderObject","importRapier","init","Physics","children","timeStep","paused","interpolate","updateLoop","debug","gravity","allowedLinearError","predictionDistance","numSolverIterations","numAdditionalFrictionIterations","numInternalPgsIterations","minIslandSize","maxCcdSubsteps","contactNaturalFrequency","lengthUnit","invalidate","rigidBodyStates","Map","colliderStates","rigidBodyEvents","colliderEvents","eventQueue","Set","worldProxy","resetWorldProxy","setWorldProxy","World","free","integrationParameters","normalizedAllowedLinearError","normalizedPredictionDistance","contact_natural_frequency","getSourceFromColliderHandle","_collider$parent","colEvents","colliderState","rigidBodyHandle","rbEvents","rigidBodyState","source","steppingState","previousState","accumulator","step","timeStepVariable","clampedDelta","clamp","stepWorld","timestep","forEachRigidBody","body","translation","interpolationAlpha","onSleep","onWake","isSleeping","_events$onSleep","_events$onWake","setMatrix","compose","invertedWorldMatrix","meshType","lerp","slerp","drainCollisionEvents","handle1","handle2","started","source1","source2","collisionPayload1","collisionPayload2","contactPair","manifold","flipped","_source1$rigidBody$ev","_source1$rigidBody$ev2","_source2$rigidBody$ev","_source2$rigidBody$ev2","_source1$collider$eve","_source1$collider$eve2","_source2$collider$eve","_source2$collider$eve2","_source1$rigidBody$ev3","_source1$rigidBody$ev4","_source2$rigidBody$ev3","_source2$rigidBody$ev4","_source1$collider$eve3","_source1$collider$eve4","_source2$collider$eve3","_source2$collider$eve4","intersectionPair","_source1$rigidBody$ev5","_source1$rigidBody$ev6","_source2$rigidBody$ev5","_source2$rigidBody$ev6","_source1$collider$eve5","_source1$collider$eve6","_source2$collider$eve5","_source2$collider$eve6","_source1$rigidBody$ev7","_source1$rigidBody$ev8","_source2$rigidBody$ev7","_source2$rigidBody$ev8","_source1$collider$eve7","_source1$collider$eve8","_source2$collider$eve7","_source2$collider$eve8","drainContactForceEvents","event","_source1$rigidBody$ev9","_source1$rigidBody$ev10","_source2$rigidBody$ev9","_source2$rigidBody$ev10","_source1$collider$eve9","_source1$collider$eve10","_source2$collider$eve9","_source2$collider$eve10","collider1","collider2","totalForce","totalForceMagnitude","maxForceDirection","maxForceMagnitude","forEachActiveRigidBody","context","setWorld","physicsOptions","isPaused","isDebug","stepCallback","Provider","_extends","assign","bind","useForwardedRef","forwardedRef","defaultValue","innerRef","useImperativeInstance","createFn","destroyFn","dependencyList","getInstance","destroy","rigidBodyDescFromOptions","_options$canSleep","canSleep","createRigidBodyState","_ref7","getMatrix","_meshType","matrix","immutableRigidBodyOptions","mutableRigidBodyOptions","gravityScale","rb","setGravityScale","additionalSolverIterations","setAdditionalSolverIterations","linearDamping","setLinearDamping","angularDamping","setAngularDamping","dominanceGroup","setDominanceGroup","enabledRotations","_ref8","setEnabledRotations","enabledTranslations","_ref9","setEnabledTranslations","lockRotations","lockTranslations","angularVelocity","_ref0","setAngvel","linearVelocity","_ref1","setLinvel","ccd","enableCcd","softCcdPrediction","setSoftCcdPrediction","setBodyType","mutableRigidBodyOptionKeys","setRigidBodyOptions","updateTranslations","useUpdateRigidBodyOptions","useRigidBodyEvents","eventHandlers","vec3","quat","euler","AnyCollider","name","rigidBodyContext","useRigidBodyContext","colliderRef","objectRef","immutablePropArray","removeCollider","mergedProps","CuboidCollider","forwardRef","displayName","RoundCuboidCollider","BallCollider","CapsuleCollider","HeightfieldCollider","TrimeshCollider","ConeCollider","RoundConeCollider","CylinderCollider","RoundCylinderCollider","ConvexHullCollider","_excluded$1","RigidBodyContext","transformState","objectProps","rigidBodyRef","mergedOptions","createRigidBody","removeRigidBody","contextValue","MeshCollider","_excluded","_excluded2","InstancedRigidBodies","_ref","rigidBodiesRef","instanceWrapperRef","instances","colliderNodes","rigidBodyProps","getInstancedMesh","firstChild","instancedMesh","instanceMatrix","setUsage","console","warn","applyInstancedState","getMatrixAt","setMatrixAt","needsUpdate","node","colliderIndex","useImpulseJoint","body1","body2","params","jointRef","newJoint","createImpulseJoint","joint","getImpulseJoint","removeImpulseJoint","useFixedJoint","_ref10","body1Anchor","body1LocalFrame","body2Anchor","body2LocalFrame","JointData","useSphericalJoint","_ref11","spherical","useRevoluteJoint","_ref12","axis","limits","revolute","limitsEnabled","usePrismaticJoint","_ref13","prismatic","useRopeJoint","_ref14","vBody1Anchor","vBody2Anchor","rope","useSpringJoint","_ref15","restLength","stiffness","damping","spring","interactionGroups","memberships","filters","bitmask","groups","flat","reduce","acc","layer"],"sources":["C:/Users/waleed/Desktop/node_modules/@react-three/rapier/dist/react-three-rapier.esm.js"],"sourcesContent":["import { Vector3 as Vector3$1, Quaternion as Quaternion$1, ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, Fragment } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferGeometry, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\nimport { suspend } from 'suspend-react';\nimport { mergeVertices } from 'three-stdlib';\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nnew Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new Vector3$1(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new Vector3$1(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new Vector3$1(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new Quaternion$1(v[0], v[1], v[2], v[3]);\n  } else {\n    return new Quaternion$1(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n  if (Array.isArray(v)) {\n    return v;\n  }\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef(undefined);\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n  return ref.current.value;\n}\n\nconst useRaf = callback => {\n  const cb = useRef(callback);\n  const raf = useRef(0);\n  const lastFrame = useRef(0);\n  useEffect(() => {\n    cb.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\n\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  useFrame((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\", \"softCcdPrediction\", \"ref\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice();\n\n  // Heightfield uses a vector\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  }\n\n  // Trimesh and convex scale the vertices\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  }\n\n  // Prepfill with some extra\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale);\n  // @ts-ignore\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setDensity(options.density);\n    return;\n  }\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setMass(options.mass);\n    return;\n  }\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  activeCollisionTypes: (collider, value) => {\n    collider.setActiveCollisionTypes(value);\n  },\n  contactSkin: (collider, value) => {\n    collider.setContactSkin(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n  if (state) {\n    var _state$worldParent;\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n    _matrix4.copy(state.object.matrixWorld);\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n    _matrix4.decompose(_position, _rotation, _scale);\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider,\n        // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    });\n\n    // handle mass separately, because the assignments\n    // are exclusive.\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n      childColliderProps.push(colliderProps);\n    }\n  };\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    const collider = getCollider();\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n  return rest;\n};\n\n// Utils\nconst useMutableCallback = fn => {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n};\n\n// External hooks\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\nconst useRapier = () => {\n  const rapier = useContext(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n// Internal hooks\n/**\n * @internal\n */\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\n\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n    mesh.geometry.dispose();\n    mesh.geometry = geometry;\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.get(instance, prop);\n    },\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.set(instance, prop, value);\n    }\n  };\n  const proxy = new Proxy({}, handler);\n  const reset = () => {\n    instance = undefined;\n  };\n  const set = newInstance => {\n    instance = newInstance;\n  };\n\n  /**\n   * Return the proxy and a reset function\n   */\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\n\nconst rapierContext = /*#__PURE__*/createContext(undefined);\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    contactNaturalFrequency = 30,\n    lengthUnit = 1\n  } = props;\n  const rapier = suspend(importRapier, [\"@react-thee/rapier\", importRapier]);\n  const {\n    invalidate\n  } = useThree();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  useEffect(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []);\n\n  // Update mutable props\n  useEffect(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.normalizedAllowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.normalizedPredictionDistance = predictionDistance;\n    worldProxy.lengthUnit = lengthUnit;\n    worldProxy.integrationParameters.contact_natural_frequency = contactNaturalFrequency;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, lengthUnit, contactNaturalFrequency]);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    var _collider$parent;\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldProxy;\n\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n    const timeStepVariable = timeStep === \"vary\";\n\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue);\n\n      // Trigger afterStep callbacks\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep;\n\n    // Update meshes\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n        state.isSleeping = rigidBody.isSleeping();\n      }\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      }\n\n      // New states\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n        // Apply previous tick position\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      }\n\n      // Get new position\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2);\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n\n          /* Collider events */\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      }\n\n      // Sensor Intersections\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2());\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = useMemo(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = useCallback(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\n};\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n// Need to catch the case where forwardedRef is a function... how to do that?\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = useRef(defaultValue);\n\n  // Update the forwarded ref when the inner ref changes\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n    return forwardedRef;\n  }\n  return innerRef;\n};\n\n/**\n * Initiate an instance and return a safe getter\n */\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = useRef(undefined);\n  const getInstance = useCallback(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n    return ref.current;\n  }, dependencyList);\n  useEffect(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n    const destroy = () => destroyFn(instance);\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type);\n\n  // Apply immutable options\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  softCcdPrediction: (rb, value) => {\n    rb.setSoftCcdPrediction(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n  const state = states.get(rigidBody.handle);\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Vector3(x, y, z);\n};\n\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new Quaternion(x, y, z, w);\n};\n\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Euler(x, y, z);\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(props.ref);\n  const objectRef = useRef(null);\n\n  // We spread the props out here to make sure that the ref is updated when the props change.\n  const immutablePropArray = immutableColliderOptions.flatMap(key =>\n  // Array.isArray(props[key]) ? [...props[key]] : props[key]\n  Array.isArray(props[key]) ? props[key] : [props[key]]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n    if (typeof props.ref == \"function\") {\n      props.ref(collider);\n    }\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  useEffect(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n});\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst _excluded$1 = [\"ref\", \"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/memo(props => {\n  const {\n      ref,\n      children,\n      type,\n      position,\n      rotation,\n      scale,\n      quaternion,\n      transformState\n    } = props,\n    objectProps = _objectWithoutProperties(props, _excluded$1);\n  const objectRef = useRef(null);\n  const rigidBodyRef = useForwardedRef(ref);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions);\n\n  // Provide a way to eagerly create rigidbody\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n    if (typeof ref === \"function\") {\n      ref(rigidBody);\n    }\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray);\n\n  // Only provide a object state after the ref has been set\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n});\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nconst _excluded = [\"ref\"],\n  _excluded2 = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/memo(_ref => {\n  let {\n      ref\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const rigidBodiesRef = useForwardedRef(ref, []);\n  const objectRef = useRef(null);\n  const instanceWrapperRef = useRef(null);\n  const {\n      // instanced props\n      children,\n      instances,\n      colliderNodes = [],\n      // wrapper object props\n      position,\n      rotation,\n      quaternion,\n      scale\n\n      // rigid body specific props, and r3f-object props\n    } = props,\n    rigidBodyProps = _objectWithoutProperties(props, _excluded2);\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n    return undefined;\n  };\n  useEffect(() => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []);\n\n  // Update the RigidBodyStates whenever the instances change\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n    return state;\n  };\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => {\n      rigidBodiesRef.current[index] = body;\n    },\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n});\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef(undefined);\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRopeJoint, useSphericalJoint, useSpringJoint, vec3 };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}