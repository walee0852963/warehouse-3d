{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/waleed/Desktop/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"children\", \"temporal\", \"frames\", \"limit\", \"blend\", \"scale\", \"opacity\", \"alphaTest\", \"color\", \"colorBlend\", \"resolution\", \"toneMapped\"],\n  _excluded2 = [\"castShadow\", \"bias\", \"mapSize\", \"size\", \"near\", \"far\", \"frames\", \"position\", \"radius\", \"amount\", \"intensity\", \"ambient\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { DiscardMaterial } from '../materials/DiscardMaterial.js';\nimport { version } from '../helpers/constants.js';\nfunction isLight(object) {\n  return object.isLight;\n}\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\nconst accumulativeContext = /* @__PURE__ */React.createContext(null);\nconst SoftShadowMaterial = /* @__PURE__ */shaderMaterial({\n  color: /* @__PURE__ */new THREE.Color(),\n  blend: 2.0,\n  alphaTest: 0.75,\n  opacity: 0,\n  map: null\n}, \"varying vec2 vUv;\\n   void main() {\\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n     vUv = uv;\\n   }\", \"varying vec2 vUv;\\n   uniform sampler2D map;\\n   uniform vec3 color;\\n   uniform float opacity;\\n   uniform float alphaTest;\\n   uniform float blend;\\n   void main() {\\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\\n     #include <tonemapping_fragment>\\n     #include <\".concat(version >= 154 ? 'colorspace_fragment' : 'encodings_fragment', \">\\n   }\"));\nconst AccumulativeShadows = /* @__PURE__ */React.forwardRef((_ref, forwardRef) => {\n  let {\n      children,\n      temporal,\n      frames = 40,\n      limit = Infinity,\n      blend = 20,\n      scale = 10,\n      opacity = 1,\n      alphaTest = 0.75,\n      color = 'black',\n      colorBlend = 2,\n      resolution = 1024,\n      toneMapped = true\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  extend({\n    SoftShadowMaterial\n  });\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const invalidate = useThree(state => state.invalidate);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    getMesh: () => gPlane.current,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      const material = gPlane.current.material;\n      material.opacity = 0;\n      material.alphaTest = 0;\n      api.count = 0;\n    },\n    update: function () {\n      let frames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      // Adapt the opacity-blend ratio to the number of frames\n      const material = gPlane.current.material;\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.alphaTest = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n      }\n\n      // Switch accumulative lights on\n      gLights.current.visible = true;\n      // Collect scene lights and meshes\n      plm.prepare();\n\n      // Update the lightmap and the accumulative lights\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      }\n      // Switch lights off\n      gLights.current.visible = false;\n      // Restore lights and meshes\n      plm.finish();\n    }\n  }), [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset();\n    // Update lightmap\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  });\n\n  // Expose api, allow children to set itself as the main light source\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      invalidate();\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"softShadowMaterial\", {\n    transparent: true,\n    depthWrite: false,\n    toneMapped: toneMapped,\n    color: color,\n    blend: colorBlend,\n    map: plm.progressiveLightMap2.texture\n  })));\n});\nconst RandomizedLight = /* @__PURE__ */React.forwardRef((_ref2, forwardRef) => {\n  let {\n      castShadow = true,\n      bias = 0.001,\n      mapSize = 512,\n      size = 5,\n      near = 0.5,\n      far = 500,\n      frames = 1,\n      position = [0, 0, 0],\n      radius = 1,\n      amount = 8,\n      intensity = version >= 155 ? Math.PI : 1,\n      ambient = 0.5\n    } = _ref2,\n    props = _objectWithoutProperties(_ref2, _excluded2);\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    var _parent$lights;\n    const group = gLights.current;\n    if (parent) (_parent$lights = parent.lights) == null || _parent$lights.set(group.uuid, api);\n    return () => {\n      var _parent$lights2;\n      return void (parent == null || (_parent$lights2 = parent.lights) == null ? void 0 : _parent$lights2.delete(group.uuid));\n    };\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n});\n\n// Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\nclass ProgressiveLightMap {\n  constructor(renderer, scene) {\n    let res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1024;\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null;\n    this.clearColor = new THREE.Color();\n    this.clearAlpha = 0;\n\n    // Create the Progressive LightMap Texture\n    const textureParams = {\n      type: THREE.HalfFloatType,\n      magFilter: THREE.NearestFilter,\n      minFilter: THREE.NearestFilter\n    };\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, textureParams);\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, textureParams);\n\n    // Inject some spicy new logic into a standard phong material\n    this.discardMat = new DiscardMaterial();\n    this.targetMat = new THREE.MeshLambertMaterial({\n      fog: false\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }';\n\n      // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + 'uniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\\n      }\";\n\n      // Set the Previous Frame's Texture Buffer and Averaging Window\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n  clear() {\n    this.renderer.getClearColor(this.clearColor);\n    this.clearAlpha = this.renderer.getClearAlpha();\n    this.renderer.setClearColor('black', 1);\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(null);\n    this.renderer.setClearColor(this.clearColor, this.clearAlpha);\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isGeometry(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.discardMat);\n  }\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n  configure(object) {\n    this.object = object;\n  }\n  update(camera) {\n    let blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    if (!this.object) return;\n    // Set each object's material to the UV Unwrapped Surface Mapping Version\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat;\n    // Ping-pong two surface buffers for reading/writing\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n    // Render the object's surface maps\n    const oldBg = this.scene.background;\n    this.scene.background = null;\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n    this.scene.background = oldBg;\n  }\n}\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };","map":{"version":3,"names":["_extends","THREE","React","extend","useThree","useFrame","shaderMaterial","DiscardMaterial","version","isLight","object","isGeometry","geometry","accumulativeContext","createContext","SoftShadowMaterial","color","Color","blend","alphaTest","opacity","map","concat","AccumulativeShadows","forwardRef","_ref","children","temporal","frames","limit","Infinity","scale","colorBlend","resolution","toneMapped","props","_objectWithoutProperties","_excluded","gl","state","scene","camera","invalidate","gPlane","useRef","gLights","plm","useState","ProgressiveLightMap","useLayoutEffect","configure","current","api","useMemo","lights","Map","Math","max","count","getMesh","reset","clear","material","update","arguments","length","undefined","min","visible","prepare","i","forEach","light","finish","useImperativeHandle","createElement","traverse","ref","Provider","value","receiveShadow","rotation","PI","transparent","depthWrite","progressiveLightMap2","texture","RandomizedLight","_ref2","castShadow","bias","mapSize","size","near","far","position","radius","amount","intensity","ambient","_excluded2","Vector3","parent","useContext","useCallback","l","random","set","MathUtils","randFloatSpread","lambda","acos","phi","cos","abs","sin","_parent$lights","group","uuid","_parent$lights2","delete","Array","from","_","index","key","attach","args","constructor","renderer","res","buffer1Active","meshes","clearColor","clearAlpha","textureParams","type","HalfFloatType","magFilter","NearestFilter","minFilter","progressiveLightMap1","WebGLRenderTarget","discardMat","targetMat","MeshLambertMaterial","fog","previousShadowMap","averagingWindow","onBeforeCompile","shader","vertexShader","slice","bodyStart","fragmentShader","indexOf","uniforms","getClearColor","getClearAlpha","setClearColor","setRenderTarget","push","mesh","blendWindow","activeMap","inactiveMap","oldBg","background","render"],"sources":["C:/Users/waleed/Desktop/node_modules/@react-three/drei/core/AccumulativeShadows.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { DiscardMaterial } from '../materials/DiscardMaterial.js';\nimport { version } from '../helpers/constants.js';\n\nfunction isLight(object) {\n  return object.isLight;\n}\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\nconst accumulativeContext = /* @__PURE__ */React.createContext(null);\nconst SoftShadowMaterial = /* @__PURE__ */shaderMaterial({\n  color: /* @__PURE__ */new THREE.Color(),\n  blend: 2.0,\n  alphaTest: 0.75,\n  opacity: 0,\n  map: null\n}, `varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }`, `varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n   }`);\nconst AccumulativeShadows = /* @__PURE__ */React.forwardRef(({\n  children,\n  temporal,\n  frames = 40,\n  limit = Infinity,\n  blend = 20,\n  scale = 10,\n  opacity = 1,\n  alphaTest = 0.75,\n  color = 'black',\n  colorBlend = 2,\n  resolution = 1024,\n  toneMapped = true,\n  ...props\n}, forwardRef) => {\n  extend({\n    SoftShadowMaterial\n  });\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const invalidate = useThree(state => state.invalidate);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    getMesh: () => gPlane.current,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      const material = gPlane.current.material;\n      material.opacity = 0;\n      material.alphaTest = 0;\n      api.count = 0;\n    },\n    update: (frames = 1) => {\n      // Adapt the opacity-blend ratio to the number of frames\n      const material = gPlane.current.material;\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.alphaTest = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n      }\n\n      // Switch accumulative lights on\n      gLights.current.visible = true;\n      // Collect scene lights and meshes\n      plm.prepare();\n\n      // Update the lightmap and the accumulative lights\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      }\n      // Switch lights off\n      gLights.current.visible = false;\n      // Restore lights and meshes\n      plm.finish();\n    }\n  }), [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset();\n    // Update lightmap\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  });\n\n  // Expose api, allow children to set itself as the main light source\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      invalidate();\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"softShadowMaterial\", {\n    transparent: true,\n    depthWrite: false,\n    toneMapped: toneMapped,\n    color: color,\n    blend: colorBlend,\n    map: plm.progressiveLightMap2.texture\n  })));\n});\nconst RandomizedLight = /* @__PURE__ */React.forwardRef(({\n  castShadow = true,\n  bias = 0.001,\n  mapSize = 512,\n  size = 5,\n  near = 0.5,\n  far = 500,\n  frames = 1,\n  position = [0, 0, 0],\n  radius = 1,\n  amount = 8,\n  intensity = version >= 155 ? Math.PI : 1,\n  ambient = 0.5,\n  ...props\n}, forwardRef) => {\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    var _parent$lights;\n    const group = gLights.current;\n    if (parent) (_parent$lights = parent.lights) == null || _parent$lights.set(group.uuid, api);\n    return () => {\n      var _parent$lights2;\n      return void (parent == null || (_parent$lights2 = parent.lights) == null ? void 0 : _parent$lights2.delete(group.uuid));\n    };\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n});\n\n// Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\nclass ProgressiveLightMap {\n  constructor(renderer, scene, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null;\n    this.clearColor = new THREE.Color();\n    this.clearAlpha = 0;\n\n    // Create the Progressive LightMap Texture\n    const textureParams = {\n      type: THREE.HalfFloatType,\n      magFilter: THREE.NearestFilter,\n      minFilter: THREE.NearestFilter\n    };\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, textureParams);\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, textureParams);\n\n    // Inject some spicy new logic into a standard phong material\n    this.discardMat = new DiscardMaterial();\n    this.targetMat = new THREE.MeshLambertMaterial({\n      fog: false\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }';\n\n      // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + 'uniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\n      }`;\n\n      // Set the Previous Frame's Texture Buffer and Averaging Window\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n  clear() {\n    this.renderer.getClearColor(this.clearColor);\n    this.clearAlpha = this.renderer.getClearAlpha();\n    this.renderer.setClearColor('black', 1);\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(null);\n    this.renderer.setClearColor(this.clearColor, this.clearAlpha);\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isGeometry(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.discardMat);\n  }\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n  configure(object) {\n    this.object = object;\n  }\n  update(camera, blendWindow = 100) {\n    if (!this.object) return;\n    // Set each object's material to the UV Unwrapped Surface Mapping Version\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat;\n    // Ping-pong two surface buffers for reading/writing\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n    // Render the object's surface maps\n    const oldBg = this.scene.background;\n    this.scene.background = null;\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n    this.scene.background = oldBg;\n  }\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}